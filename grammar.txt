# FlowCalculation Mini-DSL Grammar (LL(1) format)
# Start symbol: program

# Productions (left recursion eliminated for LL(1))

# Program
program -> stmt program_tail
program_tail -> NL opt_stmt program_tail | epsilon
opt_stmt -> stmt | epsilon

# Statements
stmt -> bind_stmt | set_stmt | when_stmt | each_stmt | def_stmt | yield_stmt | expr

bind_stmt -> BIND id ASSIGN expr
set_stmt -> SET id UPDATE expr
when_stmt -> WHEN expr DO block otherwise_opt END
otherwise_opt -> OTHERWISE DO block | epsilon
each_stmt -> EACH id IN expr DO block END
def_stmt -> DEF id LPAREN param_list_opt RPAREN DO block END
yield_stmt -> YIELD expr

# Block
block -> NL block | stmt block_tail
block_tail -> NL opt_stmt block_tail | epsilon

# Parameter list
param_list_opt -> id param_list_tail | epsilon
param_list_tail -> COMMA id param_list_tail | epsilon

# Expression hierarchy (left recursion eliminated)
expr -> pipe_expr

pipe_expr -> logic_or pipe_expr_tail
pipe_expr_tail -> PIPELINE stage pipe_expr_tail | epsilon

stage -> call | stage_keyword

stage_keyword -> APPLY LPAREN lambda RPAREN | KEEP LPAREN lambda RPAREN | ORDER LPAREN order_kw RPAREN | DEDUPE LPAREN RPAREN | TAKE LPAREN expr RPAREN | SKIP LPAREN expr RPAREN | CONCAT LPAREN expr RPAREN | JOINSTR LPAREN expr RPAREN | TOTAL LPAREN RPAREN | COUNT LPAREN RPAREN | AVG LPAREN RPAREN

lambda -> id LAMBDA expr

order_kw -> ASC | DESC

logic_or -> logic_and logic_or_tail
logic_or_tail -> OR logic_and logic_or_tail | epsilon

logic_and -> equality logic_and_tail
logic_and_tail -> AND equality logic_and_tail | epsilon

equality -> relation equality_tail
equality_tail -> EQ relation equality_tail | NE relation equality_tail | epsilon

relation -> add relation_tail
relation_tail -> LT add relation_tail | LE add relation_tail | GT add relation_tail | GE add relation_tail | epsilon

add -> mul add_tail
add_tail -> PLUS mul add_tail | MINUS mul add_tail | epsilon

mul -> unary mul_tail
mul_tail -> MUL unary mul_tail | DIV unary mul_tail | MOD unary mul_tail | epsilon

unary -> NOT unary | MINUS unary | power

power -> primary power_tail
power_tail -> POW unary power_tail | epsilon

primary -> RANGE | number primary_tail | string | bool | NONE | LPAREN expr RPAREN | list_lit | IDENTIFIER primary_after_ident | TOTAL primary_after_ident | COUNT primary_after_ident | AVG primary_after_ident | APPLY primary_after_ident | KEEP primary_after_ident | ORDER primary_after_ident | DEDUPE primary_after_ident | TAKE primary_after_ident | SKIP primary_after_ident | CONCAT primary_after_ident | JOINSTR primary_after_ident

primary_after_ident -> LPAREN arg_list_opt RPAREN | LAMBDA expr | epsilon

primary_tail -> RANGE_DOT expr | RANGE_DOT_LT expr | epsilon

# Range literal terminal (merged by PIF generator)
range -> RANGE

arg_list_opt -> expr arg_list_tail | epsilon
arg_list_tail -> COMMA expr arg_list_tail | epsilon

list_lit -> LBRACKET expr_list_opt RBRACKET

expr_list_opt -> expr expr_list_tail | epsilon
expr_list_tail -> COMMA expr expr_list_tail | epsilon


# Terminals
id -> IDENTIFIER | TOTAL | COUNT | AVG | APPLY | KEEP | ORDER | DEDUPE | TAKE | SKIP | CONCAT | JOINSTR
number -> NUMBER
string -> STRING
bool -> BOOL_LIT
